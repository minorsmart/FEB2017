---
title: "Entrepreneurial behaviour"
output: html_notebook
---

Participants of MSI are monitoring their entrepreneurial growth. They regularly reflect on their actions and record their behaviour via a online form.

In this exercise we are going to read in the values from the Google spreadsheet and perform some standard operations on the data. First we'll load the necessary libraries.

```{r}
library(gsheet)
library(dplyr)
library(reshape2)
library(ggplot2)
library(radarchart)
```

The first library is `gsheet`. This package contains some functions that allow direct downloading of data from Google Spreadsheets. The link to the spreadheet can be obtained using the sharing functionality of the Google document. We will store the data into a data frame and explore the data a bit.

```{r}
## Read in the data
url <- "https://docs.google.com/spreadsheets/d/1gq-DXkAf4QpZKcgQnABv634DKXjTCHepUi5rHw19Yeg/edit?usp=sharing"
dfData <- gsheet2tbl(url)

## View the first few records
head(dfData)

## Explore the structure of the data set
str(dfData)
```

What we got is just a copy of the spreadsheet. Currently it has `r dim(dfData)[1]` rows and `r dim(dfData)[2]` columns. The first column contains the names of all participants and the remaining columns have string values consisting of some quality factor ("Soms" or "Vaak") and a number between brackets.

The purpose of any analytics exercise is to make some sense of the large amount of data. In this case we are first going to calculate some means. The columns in the data frame can be grouped by the characters Z, U, S and V. So the initial thing to do is to select columns containing the same character. For this we use a so called regular expression (or regex). If you want to know more about regex and do some testing you can use [this site]("http://regexr.com/"). The `select()` function belongs to the `dplyr` package.

```{r}
zCols <- select(dfData, matches("Z[0-9]"))
uCols <- select(dfData, matches("U[0-9]"))
sCols <- select(dfData, matches("S[0-9]"))
vCols <- select(dfData, matches("V[0-9]"))
```

Now we have four separate data frames containing the responses of the participants per set of questions. We can still not work with this data (why not?). To proceed we are going to build a function that we can later on apply to our data. The function takes in a value, first deletes all non-numeric characters (using regex again) and then changes the format to numeric.

```{r}
cleanCols <- function(x) {
  as.numeric(
    gsub(pattern = "[A-Z][a-z]*\\s\\(|\\)", replacement = "", x)
  )
}
```

When we apply this function to all the cells in the data frames, we can start calculating.

```{r}
zCols <- data.frame(apply(zCols,2, cleanCols))
uCols <- data.frame(apply(uCols,2, cleanCols))
sCols <- data.frame(apply(sCols,2, cleanCols))
vCols <- data.frame(apply(vCols,2, cleanCols))
```

Now we will calculate per row the mean value and combine the results in a new data frame. We will also add the participants names.

```{r}
dfMeans <- data.frame(Z = rowMeans(zCols), U = rowMeans(uCols), S = rowMeans(sCols), V = rowMeans(vCols))
newMeans <- cbind(dfData[2],dfMeans)
```

Have a look at the data. What is the structure?

In the next step we are going to plot the data. The package we will use (`ggplot2`) works better with the so called long data format. It is very easy to transform our data set to this format. The package `reshape2` has a function `melt()` that does exactly what we want.

```{r}
meltMeans <- melt(newMeans)
```

Now we can make a simple bar plot.

```{r, echo=TRUE, message=FALSE, warning=FALSE}
meanPlot <- ggplot(meltMeans) + 
  geom_col(aes(x = Naam.deelnemer, y = value, col = variable, fill = variable)) +
  theme(axis.text.x = element_text(angle=90))
meanPlot
```

**De opdracht voor deze oefening luidt:** Vul het formulier opnieuw in en bouw een grafiek met alleen jouw eigen data. Op de x-as staan de time-stamps.